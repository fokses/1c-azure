#Область Криптография

Функция HMACSHA256(Знач Ключ, Знач Данные)  Экспорт
	
	Если ТипЗнч(Ключ) = Тип("Строка") И НЕ ПустаяСтрока(Ключ) Тогда
		Ключ = ПолучитьДвоичныеДанныеИзСтроки(Ключ);
	ИначеЕсли ТипЗнч(Ключ) <> Тип("ДвоичныеДанные") Тогда 
		//Сообщить о том что ключ передан не верного формата
		Возврат Неопределено;
	КонецЕсли; 
	
	Если ТипЗнч(Данные) = Тип("Строка") И НЕ ПустаяСтрока(Данные) Тогда
		Данные = ПолучитьДвоичныеДанныеИзСтроки(Данные);
	ИначеЕсли ТипЗнч(Данные) <> Тип("ДвоичныеДанные") Тогда 
		//Сообщить о том что данные переданы не верного формата
		Возврат Неопределено;
	КонецЕсли; 
	
	Возврат HMAC(Ключ, Данные, ХешФункция.SHA256, 64);
	
КонецФункции

Функция ХешСумма(ДвДанные, Тип)
	
	Хеширование = Новый ХешированиеДанных(Тип);
	Хеширование.Добавить(ДвДанные);
	
	Возврат Хеширование.ХешСумма;
	
КонецФункции

// Функция - HMAC
//
// Параметры:
//  К			 - ДвоичныеДанные - ключ шифрования
//  Данные		 - ДвоичныеДанные	- данные для шифрования
//  Тип			 - ХешФункция - 
//  РазмерБлока	 - 	Число - 
// 
// Возвращаемое значение:
//   -  ДвоичныеДанные
//
Функция HMAC(Знач К, Знач Данные, Тип = Неопределено, РазмерБлока = 64)
	
	Если Тип = Неопределено Тогда
		Тип = ХешФункция.MD5;	
	КонецЕсли; 
	
	Если К.Размер() > РазмерБлока Тогда
		К = ХешСумма(К, Тип);
	ИначеЕсли К.Размер() < РазмерБлока Тогда
		К = ПолучитьHexСтрокуИзДвоичныхДанных(К);
		К = Лев(К + ПовторитьСтроку("00", РазмерБлока), РазмерБлока * 2);
	Иначе
		К = ПолучитьHexСтрокуИзДвоичныхДанных(К);
	КонецЕсли;
	
	К = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ПолучитьДвоичныеДанныеИзHexСтроки(К));
	
	ИПАД = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("36", РазмерБлока));
	ИПАД.ЗаписатьПобитовоеИсключительноеИли(0, К);
	ИПАДДвДанные = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(ИПАД);
	
	ОПАД = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("5c", РазмерБлока));
	ОПАД.ЗаписатьПобитовоеИсключительноеИли(0, К);
	ОПАДДвДанные = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(ОПАД);
	
	мДвДанные = Новый Массив;
	мДвДанные.Добавить(ИПАДДвДанные);
	мДвДанные.Добавить(Данные);
	
	Хеш1 = ХешСумма(СоединитьДвоичныеДанные(мДвДанные), Тип);
	
	мДвДанные = Новый Массив;
	мДвДанные.Добавить(ОПАДДвДанные);
	мДвДанные.Добавить(Хеш1);
	
	Возврат ХешСумма(СоединитьДвоичныеДанные(мДвДанные), Тип);
	
КонецФункции

Функция MD5(ДвДанные) Экспорт
	Хеширование = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеширование.Добавить(ДвДанные);
	
	Возврат Base64Строка(Хеширование.ХешСумма);
КонецФункции

Функция ПовторитьСтроку(Строка, Количество)
	
	Части = Новый Массив(Количество);
	Для к = 1 По Количество Цикл
		Части.Добавить(Строка);
	КонецЦикла;
	
	Возврат СтрСоединить(Части, "");
	
КонецФункции

#КонецОбласти

#Область Авторизация

// Формирует строку Canonicalized headers, которая используется для аутентификации
// https://docs.microsoft.com/en-us/rest/api/storageservices/authorize-with-shared-key#constructing-the-canonicalized-headers-string
// Параметры:
//  Заголовки	 - ТаблицаЗначений - Таблица значений с заголовками запроса
// 
// Возвращаемое значение:   Строка
//   - 
//
Функция СформироватьCanonicalizedHeaders(Заголовки)
	ЗаголовкиСтрока = "";
	
	ТаблицаЗаголовков  = Новый ТаблицаЗначений;
	ТаблицаЗаголовков.Колонки.Добавить("Заголовок");
	ТаблицаЗаголовков.Колонки.Добавить("Значение");
	
	//Выбираем все заголовки, которые начинаются с x-ms
	Для каждого ЗаголовокСтрока Из Заголовки Цикл
		Заголовок = СокрЛП(НРег(ЗаголовокСтрока.Заголовок));
		Если СтрНачинаетсяС(Заголовок, "x-ms-") Тогда
			нСтрока = ТаблицаЗаголовков.Добавить();
			нСтрока.Заголовок = Заголовок;
			нСтрока.Значение = СокрЛП(ЗаголовокСтрока.Значение);
		КонецЕсли; 	
	КонецЦикла; 
	
	ТаблицаЗаголовков.Сортировать("Заголовок возр");  //Лексикографическая сортировка
	
	//Формируем строку
	Для Каждого нСтрока Из ТаблицаЗаголовков Цикл
		ЗаголовкиСтрока  = ЗаголовкиСтрока + нСтрока.Заголовок + ":" + нСтрока.Значение + Символы.ПС;			
	КонецЦикла; 
	
	//Обрежем последний перенос строки
	ЗаголовкиСтрока = Лев(ЗаголовкиСтрока, СтрДлина(ЗаголовкиСтрока)-1);
	
	Возврат ЗаголовкиСтрока;
КонецФункции

// Сформировать заголовок Authorization, зашифровать его HMACSHA256
// и добавить в заголовки. Используется для авторизации при помощи Shared Key
//
// Параметры:
//  Параметры				 		- Структура 	- см. ИнициализацияAzure()
//  CanonicalizedHeaders		- Строка			- Строка, полученная с помощью СформироватьCanonicalizedHeaders()
//  CanonicalizedResource	 	- Строка			- 
//
Процедура ДобавитьЗаголовокAuthorizationSharedKey(Параметры, CanonicalizedHeaders = "", CanonicalizedResource = "")
	СтрокаАвторизации = "";
	
	Заголовки = Параметры.Заголовки;
	
	//Удалим заголовок на случай, если он остался от предыдущего вызова
	УдалитьЗаголовок("Authorization", Заголовки);
	
	//Формируем SignatureString
	//https://docs.microsoft.com/en-us/rest/api/storageservices/authorize-with-shared-key#constructing-the-signature-string
		
	Для каждого ЗаголовокСтрока Из Заголовки Цикл
		Если СтрНачинаетсяС(ЗаголовокСтрока.Заголовок, "x-ms-") Тогда
			Продолжить;	
		КонецЕсли; 
		Если НЕ ПустаяСтрока(ЗаголовокСтрока.Значение) Тогда
			СтрокаАвторизации = СтрокаАвторизации + ЗаголовокСтрока.Значение;		
		КонецЕсли; 	
		СтрокаАвторизации = СтрокаАвторизации + Символы.ПС;
	КонецЦикла; 
	
	СтрокаАвторизации = СтрокаАвторизации + Символы.ПС;
	
	СтрокаАвторизации = Строка(СтрокаАвторизации) + CanonicalizedHeaders + Символы.ПС;
	СтрокаАвторизации = Строка(СтрокаАвторизации) + CanonicalizedResource + Символы.ПС;
	
	СтрокаАвторизации = Лев(СтрокаАвторизации, СтрДлина(СтрокаАвторизации) -1 );
		
	SignatureString = Base64Строка(HMACSHA256( Base64Значение(Параметры.Подключение.AccountKey), ПолучитьДвоичныеДанныеИзСтроки(СтрокаАвторизации)));
	
	ПолнаяСтрокаАвторизации =  "SharedKey "+Параметры.Подключение.AccountName+":" + SignatureString;
	
	
	УстановитьЗаголовок("Authorization",  ПолнаяСтрокаАвторизации, Заголовки);
КонецПроцедуры

#КонецОбласти 

#Область СлужебныеПроцедуры
// Разложить строку на массив подстрок по разделителю
//
// Параметры:
//  ВходящаяСтрока	 - Строка	 - 
//  Разделитель		 - 	Строка - 
// 
// Возвращаемое значение:  Массив
//   - 
//
Функция РазложитьСтрокуНаПодстроки(Знач ВходящаяСтрока, Разделитель)
	
	МассивСтрок = Новый Массив();
	ВходящаяСтрока = СтрЗаменить(ВходящаяСтрока, Разделитель, Символы.ПС);
	
	Для ИндексСтроки = 1 По СтрЧислоСтрок(ВходящаяСтрока) Цикл
		Подстрока = СтрПолучитьСтроку(ВходящаяСтрока, ИндексСтроки);
		МассивСтрок.Добавить(Подстрока);
	КонецЦикла;
	
	Возврат МассивСтрок;
	
КонецФункции 

// Установить заголовок (добавляет заголовок при его отсутствии)
//
// Параметры:
//  Заголовок	 - 	Строка - 
//  Значение	 - Строка	 - 
//  Заголовки	 - ТаблицаЗначений	 - 
//
Процедура УстановитьЗаголовок(Заголовок, Значение, Заголовки)
	СтрокаЗаголовок = Заголовки.Найти(Заголовок, "Заголовок");
	Если СтрокаЗаголовок = Неопределено Тогда
		СтрокаЗаголовок = Заголовки.Добавить();
	КонецЕсли; 
	
	СтрокаЗаголовок.Заголовок = Заголовок;
	СтрокаЗаголовок.Значение = Значение;
КонецПроцедуры

// Удалить заголовок, если он присутствует
//
// Параметры:
//  Заголовок	 - Строка	 - 
//  Заголовки	 - ТаблицаЗначений - 
//
Процедура УдалитьЗаголовок(Заголовок, Заголовки)
	СтрокаПоиск = Заголовки.Найти(Заголовок, "Заголовок");
	
	Если СтрокаПоиск <> Неопределено Тогда
		Заголовки.Удалить(СтрокаПоиск);		
	КонецЕсли; 
КонецПроцедуры

// Из таблицы значений формируем соответствие, которое будет
// использоваться в качестве параметра HTTPЗапрос
//
// Параметры:
//  ТаблицаЗаголовки - ТаблицаЗначений - 
// 
// Возвращаемое значение: Соответствие
//   - 
//
Функция ЗаголовкиСоответствие(ТаблицаЗаголовки)
	Заголовки = Новый Соответствие;
	Для каждого СтрокаЗаголовок Из ТаблицаЗаголовки Цикл
		Если СтрокаЗаголовок.Заголовок = "Request" Тогда
			Продолжить;	
		КонецЕсли; 		
		
		Если НЕ ПустаяСтрока(СтрокаЗаголовок.Значение) Тогда
			Заголовки.Вставить(СтрокаЗаголовок.Заголовок, СтрокаЗаголовок.Значение);	
		КонецЕсли; 
	КонецЦикла; 			
	
	Возврат Заголовки;
КонецФункции

// Обрежем начальные и конечные пробелы, уберем символ "/" в начале и добавим его в конце.  
// Используется для приведения в "хороший" вид строки DirectoryPath, которую ввел пользователь
//
// Параметры:
//  Путь - Строка - Иерархия директорий вида "/Folder1/Folder2/Folder3/"
// 
// Возвращаемое значение:  Строка
//   - 
//
Функция ОбработатьПуть(Путь, ДобавлятьВКонце = Истина)
	
	Путь = СокрЛП(Путь);
	
	Если ПустаяСтрока(Путь) ИЛИ Путь = "/" Тогда
		Возврат "";	
	КонецЕсли; 
	
	//Обрезаем / в начале, если он есть
	Если Лев(Путь, 1) = "/" Тогда
		Путь = Сред(Путь, 2, СтрДлина(Путь)-1);	
	КонецЕсли; 
	
	//Добавляем / в конце, если его нет
	Если Прав(Путь,1) <> "/" Тогда
		Путь = Путь + "/";	
	КонецЕсли;
	
	Возврат Путь;
КонецФункции

// Добавить сообщения из одного статуса операции в другой
//
// Параметры:
//  СтатусИсточник	 - Структура - см. СтатусОперации()
//  СтатусПриемник	 - Структура - см. СтатусОперации() 
//
Процедура ДобавитьСообщенияИзСтатуса(СтатусИсточник, СтатусПриемник)
	Для каждого Сообщение Из СтатусИсточник.Сообщения Цикл
		СтатусПриемник.Сообщения.Добавить(Сообщение);	
	КонецЦикла; 		
КонецПроцедуры

// Поместить в переменную ДвДанные содержимое файла для отправки
// Если ТипЗнч(Файл)  = Тип("ДвоичныеДанные"), то заполненное ИмяФайла обязательно 
// Параметры:
//  Файл	 - ДвоичныеДанные или Файл - файл для сохранения на сервере 
//  ИмяФайла - Строка - имя, под которым файл будет сохранен
//  Статус	 - 	Структура - структура параметров (см. СтатусОперации())
//  ДвДанные - ДвоичныеДанные - Переменная, куда будет помещено содержимое файла
//
Процедура ПолучитьДвоичныеДанныеИзПеременнойФайл(Файл, ИмяФайла, Статус, ДвДанные)
	Если ТипЗнч(Файл) = Тип("ДвоичныеДанные") Тогда
		Если ИмяФайла = "" Тогда
			Статус.Отказ = Истина;
			Статус.Сообщения.Добавить("Для типа файла ""Двоичные данные"" необходимо передавать параметр ИмяБлоб");
			Возврат;
		КонецЕсли;
		ДвДанные = Файл;
	ИначеЕсли ТипЗнч(Файл) = Тип("Файл") Тогда
		Если НЕ Файл.Существует() Тогда
			Статус.Отказ = Истина;
			Статус.Сообщения.Добавить("Ошибка открытия файла " + Файл.Файл.ПолноеИмя);
			Возврат;
		КонецЕсли;
		
		Попытка
			ДвДанные = Новый ДвоичныеДанные(Файл.ПолноеИмя);
			ИмяФайла = Файл.Имя;
		Исключение
			Статус.Отказ = Истина;
			Статус.Сообщения.Добавить("Ошибка открытия файла " + Файл.Файл.ПолноеИмя);
			Возврат;
		КонецПопытки;
	Иначе
		Статус.Отказ = Истина;
		Статус.Сообщения.Добавить("Не известный тип файла. Поддерживаются типы ""Двоичные данные"" и ""Файл""");	         
		Возврат;
	КонецЕсли; 		
КонецПроцедуры

// Обработать ответ от сервера. Ответ считается успешным, если 
// HTTPОтвет.КодСостояния = КодУспешнойОперации
// Если ответ не успешен, возводим флаг Отказ
//
// Параметры:
//  HTTPОтвет			 					- 	HTTPОтвет - ответ от сервера 
//  КодУспешнойОперации	 		- Число - Код ответа, который считается для операции успешным
//  Статус				 						- Структура 	- структура параметров (см. СтатусОперации())
//
Процедура ОбработатьОтвет(HTTPОтвет, КодУспешнойОперации, Статус)
	Если ТипЗнч(HTTPОтвет) = Тип("HTTPОтвет") Тогда
		ЗаполнитьЗначенияСвойств(Статус.Ответ, HTTPОтвет);		
		Если HTTPОтвет.КодСостояния <> КодУспешнойОперации Тогда
			Статус.Отказ = Истина;
			Статус.Ответ.Тело =  HTTPОтвет.ПолучитьТелоКакСтроку();
			
			//Попытаемся прочитать код ошибки
			ЧтениеХМЛ = Новый ЧтениеXML();			
			ЧтениеХМЛ.УстановитьСтроку(Статус.Ответ.Тело);
			ОтветСтруктура = ЧитатьКакСтруктуру(ЧтениеХМЛ);
			Попытка
				Статус.Ответ.КодОшибки = ОтветСтруктура.Error.Code;
			Исключение
			КонецПопытки;
			
		КонецЕсли; 		
	Иначе
		Статус.Отказ = Истина;
		Статус.Сообщения.Добавить("Переменная HTTPОтвет имеет тип " + ТипЗнч(HTTPОтвет));
	КонецЕсли; 		
КонецПроцедуры

// Преобразовать дату в формат, который используется в заголовках Azure
//
// Параметры:
//  Дата - Дата - 
// 
// Возвращаемое значение:  Строка
//   - 
//
Функция ДатаAzure(Дата)
	Возврат Формат(УниверсальноеВремя(Дата), "Л=en; ДФ='ddd, dd MMM yyyy HH:mm:ss ""GMT""'");		
КонецФункции

// Добавляем заголовки с мета-данными в ТЗ Заголовки
//
// Параметры:
//  FileMeta	 - Структура - Коллекция вида ('name'=>'value', 'name2'=>'value2')
//  Заголовки	 - ТаблицаЗначений - 
//
Процедура УстановитьМетаЗаголовки(FileMeta, Заголовки)
	Если ТипЗнч(FileMeta) = Тип("Структура") Тогда  //x-ms-meta-name
		Для каждого МетаЗаголовок Из FileMeta Цикл
			Если ПустаяСтрока(МетаЗаголовок.Ключ) Тогда
				Продолжить;	
			КонецЕсли; 
			МетаТег =  КодироватьСтроку(МетаЗаголовок.Ключ, СпособКодированияСтроки.КодировкаURL);
			МетаЗначение = КодироватьСтроку(МетаЗаголовок.Значение, СпособКодированияСтроки.КодировкаURL); 
			УстановитьЗаголовок("x-ms-meta-" + МетаТег, МетаЗначение, Заголовки); 
		КонецЦикла; 	
	КонецЕсли; 
КонецПроцедуры

// https://fastcode.im/Templates/7189
// Читает XML и преобразовывает его в структуру
// Параметры:
//  XML						 - 	ЧтениеXML - 
//  ТипПоследнегоЭлемента	 - 	 - 
// 
// Возвращаемое значение:  Структура
//   - 
//
Функция ЧитатьКакСтруктуру(XML, ТипПоследнегоЭлемента = Неопределено)
	Ветка = Новый Структура;
	Значение = "";
	
	Пока XML.Прочитать() Цикл
		ТипУзла = XML.ТипУзла;
		Если ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			ТипПоследнегоЭлемента = ТипУзлаXML.НачалоЭлемента;
			Временно = "";
			Если Ветка.Свойство(XML.Имя, Временно) Тогда
				Если ТипЗнч(Временно) <> Тип("Массив") Тогда
					ЭнЗэ = Новый Массив;
					ЭнЗэ.Добавить(Временно);
					Временно = ЭнЗэ;
					ЭнЗэ = "";
					Ветка.Удалить(XML.Имя);
					Ветка.Вставить(XML.Имя, Временно);
				КонецЕсли;
				Временно.Добавить(ЧитатьКакСтруктуру(XML, ТипПоследнегоЭлемента));
			Иначе
				Ветка.Вставить(XML.Имя, ЧитатьКакСтруктуру(XML, ТипПоследнегоЭлемента));
			КонецЕсли;
		ИначеЕсли ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			ТипПоследнегоЭлемента = ТипУзлаXML.КонецЭлемента;
			Возврат ?(ЗначениеЗаполнено(Ветка), Ветка, Значение);
		ИначеЕсли ТипУзла = ТипУзлаXML.Текст И Не ТипПоследнегоЭлемента = ТипУзлаXML.Текст Тогда
			ТипПоследнегоЭлемента = ТипУзлаXML.Текст;
			Значение = XML.Значение;
			XML.Прочитать(); //Вычитка закрывающего тега
			Возврат Значение;
		Иначе
			// игнорируем текст вне узлов
			// можем также добавлять текст вне узлов в текст, находящийся в предыдущем узле через какой нибудь спецсимвол
			// например через Таб, код ниже:
			//Временно[Временно.ВГраница()] = Временно[Временно.ВГраница()] + Символы.Таб + XML.Значение
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ветка;
КонецФункции

// Процедура - Простой аналог ЗаполнитьЗначенияСвойств для соответствия
//
// Параметры:
//  Приемник - Соответствие - 
//  Источник - Соответствие - 
//
Процедура ЗаполнитьСоответствие(Приемник, Источник) Экспорт     
	
	Для каждого Элемент из Источник Цикл
		
		ЕстьКлюч = Приемник.Получить(Элемент.Ключ) <> Неопределено;
		
		Если ЕстьКлюч тогда
			Приемник[Элемент.Ключ] = Элемент.Значение
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры
#КонецОбласти

#Область ИнициализацияИКонcтанты
// Заголовки, которые используются для авторизации с помощью Shared Key на сервисах Azure Blob, Queue и Files
// https://docs.microsoft.com/en-us/rest/api/storageservices/authorize-with-shared-key#blob-queue-and-file-services-shared-key-authorization
// Тип СписокЗначений выбран для того, чтобы порядок заголовков соблюдался (это важно)
// 
// Возвращаемое значение: СписокЗначений
//   - 
//
Функция ЗаголовкиПоУмолчанию()
	Заголовки = Новый СписокЗначений;  //для сохранения порядка используем список значений
	Заголовки.Добавить("Request", "");
	Заголовки.Добавить("Content-Encoding", "");
	Заголовки.Добавить("Content-Language", "");
	Заголовки.Добавить("Content-Length", "");
	Заголовки.Добавить("Content-MD5", "");
	Заголовки.Добавить("Content-Type", "application/octet-stream");
	Заголовки.Добавить("If-Modified-Since", "");
	Заголовки.Добавить("If-Match", "");	
	Заголовки.Добавить("If-None-Match", "");
	Заголовки.Добавить("If-Unmodified-Since", "");
	Заголовки.Добавить("Range", "");
	
	Возврат Заголовки;
КонецФункции

// Инициализация таблицы значений заголовков
// 
// Возвращаемое значение: ТаблицаЗначений
//   - 
//
Функция ИнициализацияЗаголовки() Экспорт
	Заголовки = Новый ТаблицаЗначений;
	Заголовки.Колонки.Добавить("Заголовок");
	Заголовки.Колонки.Добавить("Значение");
	
	списокЗаголовки = ЗаголовкиПоУмолчанию();
	
	Для каждого ЭлементСписка Из списокЗаголовки Цикл
		нСтрока = Заголовки.Добавить();
		нСтрока.Заголовок = ЭлементСписка.Значение;
		нСтрока.Значение  = ЭлементСписка.Представление;
	КонецЦикла; 
	
	Возврат Заголовки;
КонецФункции
 
// Инициализация параметров Azure из строки подключения
//
// Параметры:
//  СтрокаПодключения	 - 	Строка - 
// 
// Возвращаемое значение: Структура ИЛИ Неопределено
//   - 
//
Функция ИнициализацияAzure(СтрокаПодключения) Экспорт
	Отказ = Ложь;
	Параметры = Новый Структура;
	Параметры.Вставить("Подключение", Новый Структура);
	Подключение = Параметры.Подключение;
	
	МассивПараметровСтроки = РазложитьСтрокуНаПодстроки(СтрокаПодключения, ";");
	
	Для каждого СтрокаПараметр Из МассивПараметровСтроки Цикл
		ПоложениеРазделителя =  СтрНайти(СтрокаПараметр, "=");
		Если ПоложениеРазделителя > 1 Тогда
			ИмяПараметра = Лев(СтрокаПараметр, ПоложениеРазделителя - 1);	
			ЗначениеПараметра = Прав(СтрокаПараметр, СтрДлина(СтрокаПараметр) - ПоложениеРазделителя);
			Подключение.Вставить(ИмяПараметра, ЗначениеПараметра);	
		КонецЕсли; 
	КонецЦикла; 
	
	//Проверяем что в строке подключения пристуствуют необходимые ключи
	Если НЕ Подключение.Свойство("AccountName") 
		ИЛИ ПустаяСтрока(Подключение.AccountName) Тогда
		
		Отказ = Истина;
		Сообщить("В строке подключения не обнаружен параметр AccountName. Проверьте правильность строки подключения!");
	КонецЕсли; 
	
	Если НЕ Подключение.Свойство("AccountKey") ИЛИ 
		ПустаяСтрока(Подключение.AccountKey) Тогда
		
		Отказ = Истина;
		Сообщить("В строке подключения не обнаружен параметр AccountKey. Проверьте правильность строки подключения!");
	КонецЕсли; 
	
	Если НЕ Подключение.Свойство("EndpointSuffix") ИЛИ 
		ПустаяСтрока(Подключение.EndpointSuffix) Тогда
		
		Отказ = Истина;
		Сообщить("В строке подключения не обнаружен параметр EndpointSuffix. Проверьте правильность строки подключения!");
	КонецЕсли; 
	
	Если Отказ Тогда
		Возврат Неопределено;	
	КонецЕсли; 
	
	Подключение.Вставить("СтрокаПодключения", СтрокаПодключения); 
	
	Параметры.Вставить("Заголовки",  ИнициализацияЗаголовки());
	
	Возврат Параметры;
КонецФункции

// Структура, которая используется для ответа
// В ней заголовки, код состояния и тело, которое вернул сервер
// Также флаг Отказ и массив сообщений, которые выводятся в случае неудачи
// 
// Возвращаемое значение: Структура
//   - 
//
Функция СтатусОперации()
	Ответ = Новый Структура("Заголовки,КодСостояния,Тело,КодОшибки,Данные", Новый Соответствие, 0, Неопределено,"");
	Возврат Новый Структура("Отказ,Сообщения,Ответ,Данные", Ложь, Новый Массив(), Ответ, Новый Структура);		
КонецФункции

Функция ИнициализироватьСвойстваФайлаAzureFile()
	СвойстваФайла = Новый Соответствие;
	СвойстваФайла.Вставить("x-ms-type", "");
	СвойстваФайла.Вставить("Content-Length", "");
	СвойстваФайла.Вставить("Content-MD5", "");
	СвойстваФайла.Вставить("x-ms-copy-completion-time", "");
	СвойстваФайла.Вставить("x-ms-copy-status-description", "");
	СвойстваФайла.Вставить("x-ms-copy-id", "");
	СвойстваФайла.Вставить("x-ms-copy-progress", "");
	СвойстваФайла.Вставить("x-ms-copy-source", "");
	СвойстваФайла.Вставить("x-ms-copy-status", "");
	СвойстваФайла.Вставить("x-ms-server-encrypted", "");
	СвойстваФайла.Вставить("x-ms-file-permission-key", "");
	СвойстваФайла.Вставить("x-ms-file-attributes", "");
	СвойстваФайла.Вставить("x-ms-file-creation-time", "");
	СвойстваФайла.Вставить("x-ms-file-last-write-time", "");
	СвойстваФайла.Вставить("x-ms-file-change-time", "");
	СвойстваФайла.Вставить("x-ms-file-file-id", "");
	СвойстваФайла.Вставить("x-ms-file-parent-id", "");
	СвойстваФайла.Вставить("x-ms-lease-duration", "");
	СвойстваФайла.Вставить("x-ms-lease-state", "");
	СвойстваФайла.Вставить("x-ms-lease-status", "");

	Возврат СвойстваФайла;
КонецФункции
 

// Версия сервисов azure, используемая по умолчанию
// 
// Возвращаемое значение:
//   - 
//
Функция ВерсияСервисовAzureПереопределяемый()
	Возврат "2020-06-12";		
КонецФункции

// Максимальный размер двоичных данных, которые можно передать не разделяя
// с помощью метода API типа PutRange
// Возвращаемое значение: Число
//   - 
//
Функция МаксРазмерRange()
	Возврат 4194304; //4*1024*1024;		
КонецФункции
 
#КонецОбласти 

#Область ПараметрыПоУмолчанию
// Установить параметры по умолчанию для сервиса Azure Blob
//
// Параметры:
//  Параметры		 - Структура	- Структура параметров (см. ИнициализацияAzure())
//  BlobType		 - Строка	 - тип Blob, используемый по умолчанию
//  ВерсияСервисов	 - Строка	 - Версия сервисов Azure, используемая по умолчанию
//
Процедура ИспользоватьСервисAzureBlob(Параметры, BlobType = "BlockBlob", ВерсияСервисов = "") Экспорт
	Заголовки = Параметры.Заголовки;
	
	Если ВерсияСервисов = "" Тогда
		ВерсияСервисов = ВерсияСервисовAzureПереопределяемый();
	КонецЕсли;
	
	УстановитьЗаголовок("x-ms-version", ВерсияСервисов, Заголовки);
	УстановитьЗаголовок("x-ms-blob-type", BlobType, Заголовки);
	
	Параметры.Вставить("Хост", Параметры.Подключение.AccountName + ".blob." + Параметры.Подключение.EndpointSuffix);
	Параметры.Вставить("СервисAzure", "Blob");
	Параметры.Вставить("BlobType", BlobType);
	Параметры.Вставить("Версия", ВерсияСервисов);
КонецПроцедуры

// Установить параметры по умолчанию для сервиса Azure File
//
// Параметры:
//  Параметры		 - Структура	- Структура параметров (см. ИнициализацияAzure())
//  ВерсияСервисов	 - Строка	 - Версия сервисов Azure, используемая по умолчанию
//
Процедура ИспользоватьСервисAzureFile(Параметры,  ВерсияСервисов = "") Экспорт
	Заголовки = Параметры.Заголовки;
	
	Если ВерсияСервисов = "" Тогда
		ВерсияСервисов = ВерсияСервисовAzureПереопределяемый();
	КонецЕсли;
	
	УстановитьЗаголовок("x-ms-version", ВерсияСервисов, Заголовки);
	
	Параметры.Вставить("Хост", Параметры.Подключение.AccountName + ".file." + Параметры.Подключение.EndpointSuffix);
	Параметры.Вставить("СервисAzure", "File");
	Параметры.Вставить("Версия", ВерсияСервисов);
КонецПроцедуры
#КонецОбласти 

#Область КомандыREST
Функция PutBlob(Параметры, BlobName, ContainerName = "$root", ДвДанные = Неопределено)  Экспорт
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "PUT";	
	
	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", Формат(УниверсальноеВремя(ТекущаяДата()), "Л=en; ДФ='ddd, dd MMM yyyy HH:mm:ss ""GMT""'"), Заголовки);
	
	Если Параметры.BlobType = "BlockBlob" И ТипЗнч(ДвДанные) = Тип("ДвоичныеДанные") Тогда
		УстановитьЗаголовок("Content-Length", XMLСтрока(ДвДанные.Размер()), Заголовки);	
	КонецЕсли; 
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ContainerName, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(BlobName, СпособКодированияСтроки.КодировкаURL)
	);
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 
	
	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	HTTPЗапрос = Новый HTTPЗапрос(ContainerName + "/" + BlobName, соотЗаголовки);	
	Если Параметры.BlobType = "BlockBlob" И ТипЗнч(ДвДанные) = Тип("ДвоичныеДанные") Тогда
		HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДвДанные);
	КонецЕсли;
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить(КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
	
	
КонецФункции

Функция DeleteBlob(Параметры, BlobName, ContainerName = "$root") Экспорт
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "DELETE";	
	
	#Область Заловки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", Формат(УниверсальноеВремя(ТекущаяДата()), "Л=en; ДФ='ddd, dd MMM yyyy HH:mm:ss ""GMT""'"), Заголовки);
	УстановитьЗаголовок("Content-Length", "", Заголовки
	);
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ContainerName, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(BlobName, СпособКодированияСтроки.КодировкаURL)
	);
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 
	
	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	HTTPЗапрос = Новый HTTPЗапрос(ContainerName + "/" + BlobName, соотЗаголовки);	
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("DeleteBlob:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
КонецФункции

Функция GetBlob(Параметры, BlobName, ContainerName = "$root") Экспорт
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "GET";	
	
	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", Формат(УниверсальноеВремя(ТекущаяДата()), "Л=en; ДФ='ddd, dd MMM yyyy HH:mm:ss ""GMT""'"), Заголовки);
	УстановитьЗаголовок("Content-Length", "", Заголовки);
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ContainerName, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(BlobName, СпособКодированияСтроки.КодировкаURL)
	);
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 
	
	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	HTTPЗапрос = Новый HTTPЗапрос(ContainerName + "/" + BlobName, соотЗаголовки);	
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("GetBlob:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
КонецФункции

Функция CreateFile(Параметры, FileName, ShareName, Знач DirectoryPath = "", Размер = 0,
	ContentMD5 = "", Type = "file", FilePermission = "inherit", FileAttributes = "None",
	FileCreationTime="now", FileLastWriteTime = "now",
	FileMeta = Неопределено, LeaseID = "", ClientRequestId = "")  Экспорт
	
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "PUT";	
	
	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", ДатаAzure(ТекущаяДата()), Заголовки);
	УстановитьЗаголовок("x-ms-content-length", XMLСтрока(Размер), Заголовки);
	УстановитьЗаголовок("x-ms-type", Type, Заголовки);
	УстановитьЗаголовок("x-ms-file-permission", FilePermission, Заголовки);
	УстановитьЗаголовок("x-ms-file-attributes", FileAttributes, Заголовки);
	УстановитьЗаголовок("x-ms-file-creation-time",  FileCreationTime, Заголовки);
	УстановитьЗаголовок("x-ms-file-last-write-time", FileLastWriteTime, Заголовки); 
	
	Если НЕ ПустаяСтрока(ContentMD5) Тогда  //MD5
		УстановитьЗаголовок("x-ms-content-md5", ContentMD5, Заголовки); 
	КонецЕсли; 
	Если НЕ ПустаяСтрока(LeaseID) Тогда  //x-ms-lease-id
		УстановитьЗаголовок("x-ms-lease-id", LeaseID, Заголовки); 
	КонецЕсли; 
	Если НЕ ПустаяСтрока(ClientRequestId) Тогда  //x-ms-client-request-id
		УстановитьЗаголовок("x-ms-client-request-id", ClientRequestId, Заголовки); 
	КонецЕсли; 
	УстановитьМетаЗаголовки(FileMeta, Заголовки);
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	DirectoryPath = ОбработатьПуть(DirectoryPath);
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ShareName, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(DirectoryPath + FileName, СпособКодированияСтроки.URLВКодировкеURL)
	);
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 
	
	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	HTTPЗапрос = Новый HTTPЗапрос(ShareName + "/" +  DirectoryPath + FileName, соотЗаголовки);	
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("CreateFile:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
КонецФункции

Функция CreateDirectoryAzure(Параметры, Знач DirectoryPath, ShareName, 
	FilePermission = "inherit", FileAttributes = "None",
	FileCreationTime="now", FileLastWriteTime = "now",
	FileMeta = Неопределено, ClientRequestId = "") Экспорт
	
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "PUT";
	
	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", ДатаAzure(ТекущаяДата()), Заголовки);
	УстановитьЗаголовок("x-ms-file-permission", FilePermission, Заголовки);
	УстановитьЗаголовок("x-ms-file-attributes", FileAttributes, Заголовки);
	УстановитьЗаголовок("x-ms-file-creation-time",  FileCreationTime, Заголовки);
	УстановитьЗаголовок("x-ms-file-last-write-time", FileLastWriteTime, Заголовки);	
	
	Если НЕ ПустаяСтрока(ClientRequestId) Тогда  //x-ms-client-request-id
		УстановитьЗаголовок("x-ms-client-request-id", ClientRequestId, Заголовки); 
	КонецЕсли; 
	УстановитьМетаЗаголовки(FileMeta, Заголовки);
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	DirectoryPath = ОбработатьПуть(DirectoryPath);
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ShareName, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(DirectoryPath, СпособКодированияСтроки.URLВКодировкеURL),
	);
	CanonicalizedResource = CanonicalizedResource + Символы.ПС + "restype:directory";
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 
	
	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	Request_URI = "/" + ShareName + "/" + DirectoryPath + "?restype=directory"; 
	HTTPЗапрос = Новый HTTPЗапрос(Request_URI, соотЗаголовки);	
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("CreateDirectoryAzure:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
КонецФункции

Функция PutRange(Параметры, FileName, ShareName, Знач DirectoryPath = "", ДвДанные,
	Range = "", Write = "update", LeaseID = "", ВключатьMD5 = Истина)  Экспорт
	
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "PUT";

	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", ДатаAzure(ТекущаяДата()), Заголовки);
	УстановитьЗаголовок("x-ms-write", Write, Заголовки);
	
	Если ПустаяСтрока(Range) Тогда
		УстановитьЗаголовок("x-ms-range", "bytes=0-" + XMLСтрока(ДвДанные.Размер()-1), Заголовки);
	Иначе
		УстановитьЗаголовок("x-ms-range", Range, Заголовки);
	КонецЕсли; 
	Если Write = "clear" Тогда  //Если x-ms-write=clear, Content-length должен быть ""
		УстановитьЗаголовок("Content-Length", "", Заголовки);
	Иначе
		УстановитьЗаголовок("Content-Length", XMLСтрока(ДвДанные.Размер()), Заголовки); 
	КонецЕсли; 
	Если НЕ ПустаяСтрока(LeaseID) Тогда
		УстановитьЗаголовок("x-ms-lease-id", LeaseID, Заголовки);	
	КонецЕсли; 
	Если Write =  "update" Тогда
		MD5Сумма = MD5(ДвДанные);
		УстановитьЗаголовок("Content-MD5",  MD5Сумма, Заголовки);
	КонецЕсли; 
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	DirectoryPath = ОбработатьПуть(DirectoryPath);	
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ShareName, СпособКодированияСтроки.КодировкаURL),
	//КодироватьСтроку(Path, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(DirectoryPath + FileName, СпособКодированияСтроки.URLВКодировкеURL)
	);
	CanonicalizedResource = CanonicalizedResource + Символы.ПС + "comp:range";
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 
	
	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	HTTPЗапрос = Новый HTTPЗапрос(ShareName + "/" +  DirectoryPath + FileName + "?comp=range", соотЗаголовки);	
	HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДвДанные);
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("PutRange:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
	
КонецФункции

Функция GetFileAzure(Параметры, FileName, ShareName, Знач DirectoryPath,
	Range = "", LeaseID = "", ClientRequestId = "", ПроверятьMD5 = Истина)
	
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "GET";	
	
	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", ДатаAzure(ТекущаяДата()), Заголовки);
	
	Если НЕ ПустаяСтрока(Range) Тогда
		УстановитьЗаголовок("x-ms-range", Range, Заголовки);
		
		Если ПроверятьMD5 Тогда
			УстановитьЗаголовок("x-ms-range-get-content-md5", "true", Заголовки);
		КонецЕсли; 
	КонецЕсли; 
	
	Если НЕ ПустаяСтрока(LeaseID) Тогда
		УстановитьЗаголовок("x-ms-lease-id", LeaseID, Заголовки);	
	КонецЕсли; 
	
	Если НЕ ПустаяСтрока(ClientRequestId) Тогда
		УстановитьЗаголовок("x-ms-client-request-id", ClientRequestId, Заголовки);	
	КонецЕсли; 
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	DirectoryPath = ОбработатьПуть(DirectoryPath);	
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ShareName, СпособКодированияСтроки.КодировкаURL),
	//КодироватьСтроку(Path, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(DirectoryPath + FileName, СпособКодированияСтроки.URLВКодировкеURL)
	);
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 

	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	HTTPЗапрос = Новый HTTPЗапрос(ShareName + "/" + DirectoryPath + FileName, соотЗаголовки);	
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("GetFile:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
	
	
КонецФункции

Функция LeaseFileAzure(Параметры, FileName, ShareName, Знач DirectoryPath,
	LeaseAction, LeaseDuration = "-1", LeaseID = "", ProposedLeaseId = "", ClientRequestId = "")
	
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "PUT";	
	
	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", ДатаAzure(ТекущаяДата()), Заголовки);
	УстановитьЗаголовок("x-ms-lease-action", LeaseAction, Заголовки);

	Если (LeaseAction = "acquire" ИЛИ LeaseAction = "change" ИЛИ LeaseAction = "release") И НЕ ПустаяСтрока(LeaseID) Тогда
		УстановитьЗаголовок("x-ms-lease-id", LeaseID, Заголовки) 	
	КонецЕсли; 	
	
	Если LeaseAction = "acquire" И НЕ ПустаяСтрока(LeaseDuration) Тогда
		УстановитьЗаголовок("x-ms-lease-duration", XMLСтрока(LeaseDuration), Заголовки);
	КонецЕсли; 
	
	Если (LeaseAction = "acquire" ИЛИ LeaseAction = "change") И НЕ ПустаяСтрока(ProposedLeaseId) Тогда
		УстановитьЗаголовок("x-ms-proposed-lease-id", 	ProposedLeaseId, Заголовки);
	КонецЕсли;   
		
	Если НЕ ПустаяСтрока(ClientRequestId) Тогда
		УстановитьЗаголовок("x-ms-client-request-id", ClientRequestId, Заголовки);	
	КонецЕсли; 
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	DirectoryPath = ОбработатьПуть(DirectoryPath);	
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ShareName, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(DirectoryPath + FileName, СпособКодированияСтроки.URLВКодировкеURL)
	);
	CanonicalizedResource = CanonicalizedResource + Символы.ПС + "comp:lease";
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 

	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	HTTPЗапрос = Новый HTTPЗапрос(ShareName + "/" + DirectoryPath + FileName + "?comp=lease", соотЗаголовки);	
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("LeaseFileAzure:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
	
	
КонецФункции

Функция GetFilePropertiesAzure(Параметры, FileName, ShareName, Знач DirectoryPath,
	ShareSnapshot = "", LeaseID = "", ClientRequestId = "")
	
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "HEAD";	
	
	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", ДатаAzure(ТекущаяДата()), Заголовки);
		
	Если НЕ ПустаяСтрока(LeaseID) Тогда
		УстановитьЗаголовок("x-ms-lease-id", LeaseID, Заголовки) 	
	КонецЕсли; 	
		
	Если НЕ ПустаяСтрока(ClientRequestId) Тогда
		УстановитьЗаголовок("x-ms-client-request-id", ClientRequestId, Заголовки);	
	КонецЕсли; 
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	DirectoryPath = ОбработатьПуть(DirectoryPath);	
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ShareName, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(DirectoryPath + FileName, СпособКодированияСтроки.URLВКодировкеURL)
	);
	Если НЕ ПустаяСтрока(ShareSnapshot) Тогда
		CanonicalizedResource = CanonicalizedResource + Символы.ПС + "sharesnapshot:"+ShareSnapshot;
	КонецЕсли; 
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 

	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	HTTPЗапрос = Новый HTTPЗапрос(ShareName + "/" + DirectoryPath + FileName 
		+ ?(ПустаяСтрока(ShareSnapshot), "", "?sharesnapshot="+ShareSnapshot), соотЗаголовки);	
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("GetFilePropertiesAzure:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
КонецФункции

Функция DeleteFileAzure(Параметры, FileName, ShareName, Знач DirectoryPath,
	LeaseID = "", ClientRequestId = "")
	
	Заголовки = Параметры.Заголовки;
	МетодHTTP = "DELETE";	
	
	#Область Заголовки
	УстановитьЗаголовок("Request", МетодHTTP, Заголовки);
	УстановитьЗаголовок("x-ms-date", ДатаAzure(ТекущаяДата()), Заголовки);
		
	Если НЕ ПустаяСтрока(LeaseID) Тогда
		УстановитьЗаголовок("x-ms-lease-id", LeaseID, Заголовки) 	
	КонецЕсли; 	
		
	Если НЕ ПустаяСтрока(ClientRequestId) Тогда
		УстановитьЗаголовок("x-ms-client-request-id", ClientRequestId, Заголовки);	
	КонецЕсли; 
	
	CanonicalizedHeaders = СформироватьCanonicalizedHeaders(Заголовки);	
	
	DirectoryPath = ОбработатьПуть(DirectoryPath);	
	CanonicalizedResource = СтрШаблон(
	"/%1/%2/%3",
	Параметры.Подключение.AccountName,
	КодироватьСтроку(ShareName, СпособКодированияСтроки.КодировкаURL),
	КодироватьСтроку(DirectoryPath + FileName, СпособКодированияСтроки.URLВКодировкеURL)
	);
	
	ДобавитьЗаголовокAuthorizationSharedKey(Параметры,  CanonicalizedHeaders,  CanonicalizedResource);
	#КонецОбласти 

	соотЗаголовки = ЗаголовкиСоответствие(Заголовки);
	
	HTTPСоединение = Новый  HTTPСоединение(Параметры.Хост,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	
	HTTPЗапрос = Новый HTTPЗапрос(ShareName + "/" + DirectoryPath + FileName, соотЗаголовки);	
	
	Попытка
		ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодHTTP, HTTPЗапрос);
		Возврат ОтветHTTP;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		Сообщить("DeleteFileAzure:" + КраткоеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Внимание);
		Возврат Неопределено;
	КонецПопытки; 
КонецФункции
#КонецОбласти 

#Область ПрограмныйИнтерфейс

#Область AzureBlob
Функция СохранитьФайлBlob(СтрокаПодключения, Файл, ИмяБлоб = "", ИмяКонтейнера = "$root", ПроверятьMD5 = Истина)  Экспорт
	Перем ДвДанныеПередать;
	
	Статус = СтатусОперации();
	
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 	
	
	ПолучитьДвоичныеДанныеИзПеременнойФайл(Файл, ИмяБлоб, Статус, ДвДанныеПередать);
	Если Статус.Отказ Тогда Возврат Статус;	КонецЕсли; 
	
	ИспользоватьСервисAzureBlob(ПараметрыAzure);
	ОтветHTTPPutBlob = PutBlob(ПараметрыAzure, ИмяБлоб, ИмяКонтейнера, ДвДанныеПередать); 
	ОбработатьОтвет(ОтветHTTPPutBlob, 201, Статус);
	
	Если НЕ Статус.Отказ И ПроверятьMD5 Тогда
		ЗаголовокMD5 = ОтветHTTPPutBlob.Заголовки.Получить("Content-MD5");
		ФайлMD5 = MD5(ДвДанныеПередать);
		
		Если ЗаголовокMD5 <> ФайлMD5 Тогда //Произошла ошибка при передаче. Попытаемся удалить наш созданный blob
			Статус.Отказ = Истина;
			Статус.Сообщения.Добавить("Сумма MD5 не сходится. Вероятно, произошел сбой при передаче");
			СтатусУдаления = УдалитьBlob(СтрокаПодключения, ИмяБлоб, ИмяКонтейнера);
			Если НЕ СтатусУдаления.Отказ Тогда
				Статус.Сообщения.Добавить("Сбойный файл успешно удален");	
			Иначе
				Статус.Сообщение.Добавить("Удаление  сбойного файла не удалось!");
				ДобавитьСообщенияИзСтатуса(СтатусУдаления, Статус);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
		
	Возврат Статус;
КонецФункции
 
Функция УдалитьBlob(СтрокаПодключения, ИмяБлоб, ИмяКонтейнера = "$root")   Экспорт
	Статус = СтатусОперации();
		
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 	

	ИспользоватьСервисAzureBlob(ПараметрыAzure);
	ОтветHTTP = DeleteBlob(ПараметрыAzure, ИмяБлоб, ИмяКонтейнера); 
	ОбработатьОтвет(ОтветHTTP, 202, Статус);
		
	Возврат Статус;
КонецФункции

Функция ПолучитьФайлBlob(СтрокаПодключения, ИмяБлоб, ИмяКонтейнера = "$root", ПроверятьMD5 = Истина) Экспорт
	Статус = СтатусОперации();
		
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 	
	
	ИспользоватьСервисAzureBlob(ПараметрыAzure);
	ОтветHTTP = GetBlob(ПараметрыAzure, ИмяБлоб, ИмяКонтейнера); 
	ОбработатьОтвет(ОтветHTTP, 200, Статус);
	
	//Проверяем MD5
	Если НЕ Статус.Отказ Тогда  //Если код ответа верный
		ДвДанныеОтвет =  ОтветHTTP.ПолучитьТелоКакДвоичныеДанные();		
		
		Если ПроверятьMD5 Тогда  //проверим тело на правильность
	    	ДвДанныеMD5 = MD5(ДвДанныеОтвет);
			ЗаголовокMD5 = ОтветHTTP.Заголовки.Получить("Content-MD5");
			
			Если ЗаголовокMD5 = ДвДанныеMD5 Тогда
				Статус.Ответ.Тело  = ДвДанныеОтвет;
			Иначе //не сошлась контрольная сумма
				Статус.Отказ = Истина;
				Статус.Сообщения.Добавить("Не сошлась контрольная сумма полученного файла");	
			КонецЕсли;
		Иначе   //помести тело в переменную без проведения проверки
			Статус.Ответ.Тело  = ДвДанныеОтвет;	
		КонецЕсли; 
	КонецЕсли;
		
	Возврат Статус;
КонецФункции

#КонецОбласти

#Область AzureFile
// Сохранить файл на сервисе Azure File. Есть возможность проверить целостность полученных
// данных с помощью MD5.
//
// Параметры:
//  СтрокаПодключения		 	- Строка	-  Строка подключения, скопированная из сервиса 
//  Файл					 					- ДвоичныеДанные или Файл -  Файл, который необходимо сохранить
//  ИмяФайла				 				- Строка	- Имя, под которым файл будет сохранен на сервисе 
	// (обязателен, если ТипЗнч(Файл) = Тип("ДвоичныеДанные"))
//  FileShare				 				- Строка - Наименование файловой шары Azure
//  Путь					 					- Строка	- Строка вида "Folder1/Folder2/Folder3"
	// путь, по которому положить файл на сервисе. Если  СоздаватьИерархиюПапок = истина,
	// путь буден создан
//  ПроверятьMD5			 			- Булево - Проверять целостность полученных данных
//  СоздаватьИерархиюПапок	- Булево	- Создавать папки пути, которых не существует
//  МетаТеги 								- Структура - Мета теги, которые будут сохранены у файла
// 
// Возвращаемое значение: Структура (см. СтатусОперации())
//   - 
//
Функция СохранитьФайлAzureFile(СтрокаПодключения, Файл, ИмяФайла = "", ShareName, DirectoryPath = "", 
	СохранитьMD5 = Истина, СоздаватьИерархиюПапок = Истина, МетаТеги = Неопределено) Экспорт
	
	Перем ДвДанныеПередать;
	
	Статус = СтатусОперации();		
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 	
	
	ПолучитьДвоичныеДанныеИзПеременнойФайл(Файл, ИмяФайла, Статус, ДвДанныеПередать);
	Если Статус.Отказ Тогда Возврат Статус;	КонецЕсли; 
		
	//1. Создаем иерархию папок, если необходимо
	Если СоздаватьИерархиюПапок И НЕ ПустаяСтрока(DirectoryPath) Тогда  //Создаем иерархию директорий
		СтатусИерархияДиректорий = СоздатьИерархиюДиректорийAzureFile(СтрокаПодключения, DirectoryPath, ShareName);
		Если СтатусИерархияДиректорий.Отказ Тогда //в создании иерархии директорий произошла ошибка
			Статус.Отказ = Истина; 	
			ДобавитьСообщенияИзСтатуса(СтатусИерархияДиректорий, Статус);
			Возврат Статус;
		КонецЕсли; 
	КонецЕсли; 
	
	//2. Создаем файл
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	ИспользоватьСервисAzureFile(ПараметрыAzure);
	ОтветCreateFile = CreateFile(ПараметрыAzure, ИмяФайла, ShareName, DirectoryPath, 
		ДвДанныеПередать.Размер(), ?(СохранитьMD5, MD5(ДвДанныеПередать), Неопределено),,,,,,МетаТеги); 
	ОбработатьОтвет(ОтветCreateFile, 201, Статус);
	Если Статус.Отказ Тогда Возврат Статус;	КонецЕсли; 
	
	//3. Передаем файл, при превынии макс. размера, передаем через несколько запросов
	РазмерДвДанных = ДвДанныеПередать.Размер();
	МаксРазмер = МаксРазмерRange(); //Максимальный размер в байтах для отправки одним куском
	
	ПараметрыAzure.Заголовки = ИнициализацияЗаголовки(); 	//Установим заголовки по умолчанию
	ИспользоватьСервисAzureFile(ПараметрыAzure); //Установим заголовки по умолчанию
	
	Если РазмерДвДанных <= МаксРазмер Тогда
		ОтветPutRange = PutRange(ПараметрыAzure, ИмяФайла, 	ShareName, DirectoryPath, ДвДанныеПередать);
		ОбработатьОтвет(ОтветPutRange, 201, Статус);
	Иначе //Формируем поток и читаем его кусками размером МаксРазмер
		Поток = ДвДанныеПередать.ОткрытьПотокДляЧтения();
		
		Пока НЕ Статус.Отказ И Поток.ТекущаяПозиция() < РазмерДвДанных Цикл
			КПрочтениюБайт = Мин(МаксРазмер, РазмерДвДанных - Поток.ТекущаяПозиция());
			
			//Сформируем строку Range пока не сдвинули текущую позицию
			Range = "bytes=" + XMLСтрока(Поток.ТекущаяПозиция()) + "-" + XMLСтрока(Поток.ТекущаяПозиция() + КПрочтениюБайт - 1);
			
			БуферЧастьДляОтправки = Новый БуферДвоичныхДанных(КПрочтениюБайт);
			Поток.Прочитать(БуферЧастьДляОтправки, 0, КПрочтениюБайт);
			ДвДанныеОтправить = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(БуферЧастьДляОтправки);
			
			ОтветPutRange = PutRange(ПараметрыAzure, ИмяФайла, ShareName, DirectoryPath, ДвДанныеОтправить, Range);
			ОбработатьОтвет(ОтветPutRange, 201, Статус);
		КонецЦикла; 
	КонецЕсли; 
	
	Возврат Статус;
КонецФункции
 
// Создать директорию в сервисе Azure File
//
// Параметры:
//  СтрокаПодключения	 	- Строка	 -  Строка подключения, скопированная из сервиса 
//  Путь				 					- Строка	 -  Строка вида "Folder1/Folder2/NewFolder"
//		ВНИМАНИЕ!!! Создается только последняя папка в строке (NewFolder).
//		Все родительские папки должны существовать! (или см. СоздатьИерархиюДиректорийAzureFile())
//  FileShare			 				- Строка	 -  Наименование файловой шары Azure
//  МетаТеги							- Структура - Мета теги, которые будут записаны у директории 
//  	Если папка существует, мета-теги НЕ будут добавлены
//  ОтказЕслиСуществует 		- Булево - Если создаем папку, которая существует, устанавливать флаг Отказ
//    Поведение по-умолчанию: При попытке создания уже существующей папки, операция считается успешной
// Возвращаемое значение: Структура (см. СтатусОперации())
//
Функция СоздатьДиректориюAzureFile(СтрокаПодключения, Знач DirectoryPath, ShareName, 
	МетаТеги = Неопределено, ОтказЕслиСуществует = Ложь)  Экспорт
	Статус = СтатусОперации();	
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 		
	
	ИспользоватьСервисAzureFile(ПараметрыAzure);
	ОтветHTTP = CreateDirectoryAzure(ПараметрыAzure, DirectoryPath, ShareName,,,,,МетаТеги);
	
	Если ТипЗнч(ОтветHTTP) = Тип("HTTPОтвет")  Тогда
		ЗаполнитьЗначенияСвойств(Статус.Ответ, ОтветHTTP);
		Если  ОтветHTTP.КодСостояния = 201 Тогда //Успешно создана
			//
		ИначеЕсли ОтветHTTP.КодСостояния = 409 Тогда  //Существует. Читаем XML-ответ
			ТелоОтветаСтрока = ОтветHTTP.ПолучитьТелоКакСтроку();
			ЧтениеХМЛ = Новый ЧтениеXML();
			КодОшибки = Неопределено;
			
			ЧтениеХМЛ.УстановитьСтроку(ТелоОтветаСтрока);
			ОтветСтруктура = ЧитатьКакСтруктуру(ЧтениеХМЛ);
			Попытка
				КодОшибки = ОтветСтруктура.Error.Code;
			Исключение
			КонецПопытки;
			
			Если КодОшибки = "ResourceAlreadyExists" Тогда  //Такая папка уже существует
				Статус.Сообщения.Добавить("Данный каталог """ + DirectoryPath + """ уже существует");
				Если ОтказЕслиСуществует Тогда Статус.Отказ = Истина; КонецЕсли; 
			Иначе //другой код ошибки, значит отказ
				Статус.Отказ = Истина;
				Статус.Ответ.Тело = ТелоОтветаСтрока;
			КонецЕсли; 
		Иначе //другой код состояния
			Статус.Отказ = Истина;
			Статус.Ответ.Тело =  ОтветHTTP.ПолучитьТелоКакСтроку();
		КонецЕсли;	
	КонецЕсли; 
	
	Возврат Статус;
КонецФункции
 
// Создать иерархию директорий azure file по строке DirectoryPath
// Допускается, что родительские директории (или все) могут существовать
//
// Параметры:
//  СтрокаПодключения	 	- Строка - строка подключения, скопированная из сервиса
//  Путь				 					- Строка - Строка вида "NewFolder1/NewFolder2/NewFolder3"
//  FileShare			 				- Строка -  Наименование файловой шары Azure
// 
// Возвращаемое значение: Структура (см. СтатусОперации())
//
Функция СоздатьИерархиюДиректорийAzureFile(СтрокаПодключения, Знач DirectoryPath, ShareName)
	Статус = СтатусОперации();
	DirectoryPath = ОбработатьПуть(DirectoryPath); 
	МассивПутей = РазложитьСтрокуНаПодстроки(DirectoryPath, "/");
	
	ПутьКПапке = "";
	Для каждого ТекущийПуть Из МассивПутей Цикл
		ПутьКПапке = ПутьКПапке + ?(ПустаяСтрока(ПутьКПапке), "", "/") + ТекущийПуть;	
		
		СтатусНовойПапки = СоздатьДиректориюAzureFile(СтрокаПодключения, ПутьКПапке, ShareName);
		Если НЕ СтатусНовойПапки.Отказ Тогда
			Статус.Сообщения.Добавить("Успешно создана директория " + ПутьКПапке); 		
		Иначе
			Статус.Отказ = Истина;			
			ДобавитьСообщенияИзСтатуса(СтатусНовойПапки, Статус);
			Прервать;
		КонецЕсли; 
	КонецЦикла; 
		
	Возврат Статус;
КонецФункции

// Получить файл из Azure File
//
// Параметры:
//  СтрокаПодключения	 - 	Строка - строка подключения к сервису
//  FileName			 - 	Строка -  Имя файла в Azure, который мы хотим получить
//  ShareName			 - Строка - Наименование файловой шары Azure
//  DirectoryPath		 - Строка	- Строка вида "Folder1/Folder2/Folder3/". Путь иерархии до файла
//  ПроверятьMD5		 - Булево - Проверять MD5 полученного файла. Если при создании файла, 
//    его MD5 не был передан на сервер, то заголовок Content-MD5 будет отсутствовать и проверка вернет ошибку!
// 
// Возвращаемое значение: Структура (см. СтатусОперации())
//   - 
//
Функция ПолучитьФайлAzureFile(СтрокаПодключения, FileName, ShareName, 
	Знач DirectoryPath = "", ПроверятьMD5 = Истина) Экспорт
	
	Статус = СтатусОперации();	
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 		
	
	ИспользоватьСервисAzureFile(ПараметрыAzure);
	ОтветHTTP = GetFileAzure(ПараметрыAzure, FileName, ShareName, DirectoryPath,,,,ПроверятьMD5);
	ОбработатьОтвет(ОтветHTTP, 200, Статус);
	
	Если НЕ Статус.Отказ Тогда //Проверим MD5
		ДвДанныеФайл = ОтветHTTP.ПолучитьТелоКакДвоичныеДанные(); 
		Если ПроверятьMD5 Тогда
			MD5Заголовок = Статус.Ответ.Заголовки.Получить("Content-MD5"); //если при создании файла, его MD5 не был передан, этого заголовка не будет
			Если MD5Заголовок = Неопределено Тогда
				Статус.Отказ = Истина;
				Статус.Сообщения.Добавить("В ответе от сервера отсутствует заголовок ""Content-MD5"". Проверка MD5 не возможна!");
			Иначе
				MD5ПолученныйФайл = MD5(ДвДанныеФайл);
				
				Если MD5Заголовок = MD5ПолученныйФайл Тогда
					Статус.Ответ.Тело = ДвДанныеФайл;	
				Иначе  //произошла ошибка при передаче
					Статус.Отказ = Истина;
					Статус.Сообщения.Добавить("При получении файла произошла ошибка передачи данных!");
				КонецЕсли; 
			КонецЕсли;
		Иначе //записываем дв. данные без проверки
			Статус.Ответ.Тело = ДвДанныеФайл;	
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат Статус;
КонецФункции

// Установить аренду файла в Azure File
// Устанавливает исключительный доступ на запись и удаление файла.
// Для файла с активной арендой, следующие операции API допускаются только с указанием корректного LeaseID:
//    Create File
//    Set File Metadata
//    Set File Properties
//    Delete File
//    Put Range
//    Copy File (lease ID требуется для файла получателя)
// Установка аренды не препятствует чтению файла
// https://docs.microsoft.com/en-us/rest/api/storageservices/lease-file
// Параметры:
//  СтрокаПодключения	 - Строка	 - строка подключения к сервису
//  FileName			 - 	Строка -  Имя файла в Azure, который мы хотим получить
//  ShareName			 - Строка - Наименование файловой шары Azure
//  DirectoryPath		 - Строка	- Строка вида "Folder1/Folder2/Folder3/". Путь иерархии до файла
//  ProposedLeaseId	- Строка - Идентификатор аренды. GUID строкой. 
//    Если не задан, сервер сгенерирует случайный идетификатор
// 
// Возвращаемое значение: Структура (см. СтатусОперации())
//   - 
//
Функция УстановитьАрендуAzureFile(СтрокаПодключения, FileName, ShareName, DirectoryPath = "",
	ProposedLeaseId = "")  Экспорт

	Статус = СтатусОперации();	
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 		
	
	ИспользоватьСервисAzureFile(ПараметрыAzure);
	ОтветHTTP = LeaseFileAzure(
		ПараметрыAzure, 
		FileName, 
		ShareName, 
		DirectoryPath,
		"acquire",
		-1,  //в текущей версии сервиса всегда должен быть -1 (бесконечная аренда)
		,
		ProposedLeaseId
	);
	
	ОбработатьОтвет(ОтветHTTP, 201, Статус);
	
	Возврат Статус;
КонецФункции

// Функция - Снять аренду файла в Azure File
// https://docs.microsoft.com/en-us/rest/api/storageservices/lease-file
// Параметры:
//  СтрокаПодключения	 - 	Строка - строка подключения к сервису
//  FileName			 - 	Строка -  Имя файла в Azure, который мы хотим получить
//  ShareName			 - Строка - Наименование файловой шары Azure
//  DirectoryPath		 - Строка	- Строка вида "Folder1/Folder2/Folder3/". Путь иерархии до файла
//  LeaseID				 - 	Строка - Идентификатор аренды (LeaseID). GUID строкой.
// 
// Возвращаемое значение: Структура (см. СтатусОперации())
//   - 
//
Функция СнятьАрендуAzureFile(СтрокаПодключения, FileName, ShareName, DirectoryPath = "", LeaseID)  Экспорт
	Статус = СтатусОперации();	
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 		
	
	ИспользоватьСервисAzureFile(ПараметрыAzure);
	ОтветHTTP = LeaseFileAzure(
		ПараметрыAzure, 
		FileName, 
		ShareName, 
		DirectoryPath,
		"release",
		,
		LeaseID
	);
	
	ОбработатьОтвет(ОтветHTTP, 200, Статус);
	
	Возврат Статус;
КонецФункции

// Прервать аренду в Azure File
// Принудительно прервать аренду файла. Передача LeaseID не требуется
// https://docs.microsoft.com/en-us/rest/api/storageservices/lease-file
// Параметры:
//  СтрокаПодключения	 - 	Строка - строка подключения к сервису
//  FileName			 - 	Строка -  Имя файла в Azure, который мы хотим получить
//  ShareName			 - Строка - Наименование файловой шары Azure
//  DirectoryPath		 - Строка	- Строка вида "Folder1/Folder2/Folder3/". Путь иерархии до файла
// 
// Возвращаемое значение: Структура (см. СтатусОперации())
//   - 
//
Функция ПрерватьАрендуAzureFile(СтрокаПодключения, FileName, ShareName, DirectoryPath = "") Экспорт
	Статус = СтатусОперации();	
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 		
	
	ИспользоватьСервисAzureFile(ПараметрыAzure);
	ОтветHTTP = LeaseFileAzure(
		ПараметрыAzure, 
		FileName, 
		ShareName, 
		DirectoryPath,
		"break"
	);
	
	ОбработатьОтвет(ОтветHTTP, 202, Статус);
	
	Возврат Статус;
КонецФункции

// Получить свойства файла azure file
// Получает свойства файла и помещает их в соответствие по пути Статус.Данные.СвойстваФайла
// Параметры:
//  СтрокаПодключения	 - 	Строка - строка подключения к сервису
//  FileName			 - 	Строка -  Имя файла в Azure, который мы хотим получить
//  ShareName			 - Строка - Наименование файловой шары Azure
//  DirectoryPath		 - Строка	- Строка вида "Folder1/Folder2/Folder3/". Путь иерархии до файла
//  ShareSnapshot		 - 	Строка -  Версия файла, если необходимо
//  LeaseID				 - Строка	 -  Если LeaseID задан, операция будет успешна только если аренда активна
//		и передан корректный LeaseID
// 
// Возвращаемое значение: Структура (см. СтатусОперации())
//   - 
//
Функция ПолучитьСвойстваФайлаAzureFile(СтрокаПодключения, FileName, ShareName, DirectoryPath = "",
	ShareSnapshot = "", LeaseID = "") Экспорт
	
	Статус = СтатусОперации();	
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 		
	
	ИспользоватьСервисAzureFile(ПараметрыAzure);
	ОтветHTTP = GetFilePropertiesAzure(
		ПараметрыAzure, 
		FileName, 
		ShareName, 
		DirectoryPath,
		ShareSnapshot,
		LeaseID);
	
	ОбработатьОтвет(ОтветHTTP, 200	, Статус);
	
	Если НЕ Статус.Отказ Тогда
		ЗаголовкиОтвет = Статус.Ответ.Заголовки;
		СвойстваФайла = ИнициализироватьСвойстваФайлаAzureFile();
		ЗаполнитьСоответствие(СвойстваФайла, ЗаголовкиОтвет);
		Для каждого КлючЗначение Из ЗаголовкиОтвет Цикл   //мета-заголовки
			Если СтрНачинаетсяС(КлючЗначение.Ключ, "x-ms-meta-") Тогда
				СвойстваФайла.Вставить(КлючЗначение.Ключ, РаскодироватьСтроку(КлючЗначение.Значение, СпособКодированияСтроки.КодировкаURL));	
			КонецЕсли; 	
		КонецЦикла;  
		Статус.Данные.Вставить("СвойстваФайла",  СвойстваФайла);
	КонецЕсли; 
	
	Возврат Статус;
КонецФункции

// Арендован ли файл?
//
// Параметры:
//  СтрокаПодключения	 - 	Строка - строка подключения к сервису
//  FileName			 - 	Строка -  Имя файла в Azure, который мы хотим получить
//  ShareName			 - Строка - Наименование файловой шары Azure
//  DirectoryPath		 - Строка	- Строка вида "Folder1/Folder2/Folder3/". Путь иерархии до файла
// 
// Возвращаемое значение:
//  Булево - Статус аренды
// Неопределено - При получении свойства файла произошла ошибка
//
Функция ФайлАрендован(СтрокаПодключения, FileName, ShareName, DirectoryPath = "",
	ShareSnapshot = "", LeaseID = "") Экспорт
	
	Статус = ПолучитьСвойстваФайлаAzureFile(СтрокаПодключения, FileName, ShareName, DirectoryPath, ShareSnapshot, LeaseID);
	
	Если Статус.Отказ Тогда
		Возврат Неопределено;	
	КонецЕсли; 
	
	СвойстваФайла = Статус.Данные.СвойстваФайла;
	LeaseStatus = СвойстваФайла.Получить("x-ms-lease-status");

	Если LeaseStatus = Неопределено Тогда
		Возврат Неопределено;
	Иначе
		Возврат  НРег(LeaseStatus) = "locked";
	КонецЕсли; 
КонецФункции

Функция УдалитьФайл(СтрокаПодключения, FileName, ShareName, DirectoryPath = "", LeaseID = "") Экспорт
	Статус = СтатусОперации();	
	ПараметрыAzure = ИнициализацияAzure(СтрокаПодключения);
	Если ПараметрыAzure = Неопределено Тогда Возврат Статус КонецЕсли; 		
	
	ИспользоватьСервисAzureFile(ПараметрыAzure);
	ОтветHTTP = DeleteFileAzure(ПараметрыAzure, FileName, ShareName, DirectoryPath, LeaseID);
	ОбработатьОтвет(ОтветHTTP, 202, Статус);
	
	Возврат Статус;
КонецФункции
 
#КонецОбласти 
#КонецОбласти 